package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  					program;
non terminal Axiom				axiom;
non terminal  					epsilon;
non terminal  					defconstantes;
non terminal Constante 			valorconstante;
non terminal  					seccionconstantes;
non terminal Vect				deftipos;
non terminal TipoVector			tipovector;
non terminal Constante			valorango;
non terminal  					secciontipos;
non terminal SecuenciaVariables	defvariables;
non terminal Var				tipovariable;
non terminal SecuenciaVariables	listavariables;
non terminal SecuenciaVariables	seccionvariables;
non terminal  					defsubprograma;
non terminal					puntoycomaopcional;

non terminal 					tiporetornofuncion;
non terminal  					seccionsubprograma;
non terminal  					defprincipal;
non terminal Var				selectorvalororeferencia;


non terminal Expresion			expresion;
non terminal Expresion			expresionlvl2;
non terminal Expresion			expresionlvl3;
non terminal Expresion			expresionlvl4;
non terminal Expresion			expresionlvl5;




non terminal					miembrovector;
non terminal					procedimiento;
non terminal					funcion;
non terminal					selectorpof;

non terminal           			parametrofuncionoproc;
non terminal 					llamadafuncion ; 

non terminal Expresion			parteizquierdaasignacion;  
non terminal 					sentenciadeasignacion;

non terminal 					parametroEscribir ;
non terminal 					sentenciaEscribir ;

non terminal 					sentencia;
non terminal 					sentenciaFuncion;
non terminal 					listaSentencias;
non terminal 					listaSentenciasFuncion;
non terminal 					sentenciaif;
non terminal 					sentenciaifFuncion;
non terminal 					rellenoif;
non terminal 					rellenoifFuncion;
non terminal 					sentenciafor;
non terminal 					sentenciaforFuncion;
non terminal 					sentenciaDevolver;


non terminal Expresion			parametroasignacion;

non terminal					sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA, PRODUCTO;	
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden aï¿½adir mï¿½s acciones semï¿½nticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no estÃ¡ completo. Esto es debido a que 
  		// aÃºn no se tendrÃ¡ implementada la generaciÃ³n de cÃ³digo intermedio ni final.
  		// Para la entrega final deberÃ¡n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= defprincipal;

epsilon ::=;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id
{:
	//Creamos el ámbito global con el nombre del programa principal
	String nombre = id.getLexema();
	scopeManager.openScope(nombre);
	ScopeIF scope = scopeManager.getCurrentScope();
	
	//Obtenemos del ámbito creado la Tabla de Tipos
	TypeTableIF typeTable = scope.getTypeTable();
	
	//Introducción del Tipo Simple Entero o Integer y Lógico o Booleano
	TypeSimple tsEntero = new TypeSimple(scope, "ENTERO");
	typeTable.addType("ENTERO", tsEntero);
	TypeSimple tsLogico = new TypeSimple(scope, "LOGICO");
	typeTable.addType("LOGICO", tsLogico);
:} 
DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA
{:
	scopeManager.closeScope();
:};

/*--------------------------------------------------------------------------*/
/*-------------------------------CONSTANTES---------------------------------*/
/*--------------------------------------------------------------------------*/

//Definición de constantes
defconstantes ::=   IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS {:
	//Recuperamos el ámbito dinde nos encontramos y obtenemos la tabla de sï¿½mbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symTable = scope.getSymbolTable();
	
	//Comprobamos que la constante no este ya contenida en la tabla de símmbolos
	if(symTable.containsSymbol(id.getLexema())){
		semanticErrorManager.semanticFatalError("Constante " +id.getLexema() + " en linea " + id.getLine() + " ya declarada");
	} else {
		//Introducimos en la tabla de símbolos la constante con su ámbito, nombre, tipo y valor
		TypeTableIF typeTable = scope.getTypeTable();
		TypeIF tipo = scopeManager.searchType(valor.getTipo());
		
		SymbolConstant simboloConstante = new SymbolConstant(scope, id.getLexema(), tipo);
		simboloConstante.setValor(valor.getValor());
		symTable.addSymbol(simboloConstante);	
	}
:} defconstantes 
| epsilon;
 
valorconstante ::=   FALSO 
{:
	Constante c = new Constante("LOGICO", "false");
	RESULT = c;							
:} 
| CIERTO 
{:
	Constante c = new Constante("LOGICO", "true");
	RESULT = c;							
:}
| NUM:n
{:
	Constante c = new Constante("ENTERO", n.getLexema());
	RESULT = c;							
:};

seccionconstantes ::= BCONSTANTES defconstantes | epsilon;

/*--------------------------------------------------------------------------*/
/*-------------------------------DEF TIPOS----------------------------------*/
/*--------------------------------------------------------------------------*/


// Definición de tipos (nombreTipo = vector [n1..n2] de TipoPrimitivo;)
deftipos ::=IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:v1 RANGO valorango:v2 CDERECHO ASIGNACIONVECTOR tipovector:tipoV  DSENTENCIAS deftipos 
{:
	if (Integer.parseInt(v1.getValor()) > Integer.parseInt(v2.getValor())) {
		//Dar error
		semanticErrorManager.semanticFatalError("Error fatal, parametros equivocados en el rango del vector");
	} else {
		//CREAR VECTOR CON PARAMETROS
		ScopeIF scope = scopeManager.getCurrentScope();
		TypeTableIF typeTable = scope.getTypeTable();
		
		if(typeTable.containsType(id.getLexema())){
			semanticErrorManager.semanticFatalError("El identificador "+id.getLexema()+ " en la línea "+id.getLine()+" ya está en uso");
		} else {
			TypeIF tipo = scopeManager.searchType(tipoV.getTipo());
			//Crear TypeArray
			TypeArray array = new TypeArray (scope, id.getLexema(), Integer.parseInt(v1.getValor()), Integer.parseInt(v2.getValor()), tipoV.getTipo());
			typeTable.addType(array);
		}
	}
:}
| epsilon;

tipovector ::= BOOLEANO 
{: 
	TipoVector tv = new TipoVector("LOGICO");
	RESULT = tv;
:} 
				
| ENTERO 
{: 
	TipoVector tv = new TipoVector("ENTERO");
	RESULT = tv;
:};


valorango ::= NUM:r 
{: 
	Constante c = new Constante("ENTERO", r.getLexema());
	RESULT = c;	
:} 

| IDEN:r 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();
	if (sTable.containsSymbol(r.getLexema())){
	
		//Si la tabla de símbolos contiene el símbolo
		SymbolIF simbolo = scopeManager.searchSymbol(r.getLexema());
		if (simbolo instanceof SymbolConstant) {
			SymbolConstant constante = (SymbolConstant) simbolo;
			if (simbolo.getType().getName().toString().equals("ENTERO")) {
				Constante c = new Constante("ENTERO", constante.getValor());
				RESULT = c;	
			} else {
				semanticErrorManager.semanticFatalError("Error fatal, el simbolo "+r.getLexema()+" no es de tipo ENTERO, necesario para el vector");
			}
		}
	} else {
		semanticErrorManager.semanticFatalError("Error fatal, el simbolo "+r.getLexema()+" no está definido");
	}
:}
| miembrovector;
secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

/*--------------------------------------------------------------------------*/
/*-------------------------------VARIABLES----------------------------------*/
/*--------------------------------------------------------------------------*/

// Definición de variables
tipovariable ::= BOOLEANO 
{: 
	Var v = new Var("LOGICO");
	RESULT = v;
:} 
| ENTERO 
{: 
	Var v = new Var("ENTERO");
	RESULT = v;
:} 
| IDEN:r
{: 
	Var v = new Var(r.getLexema());
	RESULT = v;
:} ;

//x, z : entero;
defvariables ::= listavariables:listaFila DELIMFUNC tipovariable:tipo puntoycomaopcional defvariables:listaAcum 
{:
	SecuenciaVariables sv = new SecuenciaVariables();	
	if (listaAcum == null){
		for (int i = 0; i < listaFila.size(); i++) {
			listaFila.getVariable(i).setTipo(tipo.getTipo());
			sv.addVariable(listaFila.getVariable(i));
		}	
	} else {
		sv.setListaVariables(listaAcum.getListaVariables());
		for (int i = 0; i < listaFila.size(); i++) {
			listaFila.getVariable(i).setTipo(tipo.getTipo());
			sv.addVariable(listaFila.getVariable(i));
		}
	}
	RESULT = sv;		
:}

| epsilon; 

listavariables ::= selectorvalororeferencia:var DIDENTIFICADORES listavariables:lista
{:
	SecuenciaVariables sv = new SecuenciaVariables();
	sv.setListaVariables(lista.getListaVariables());
	sv.addVariable(var);
	RESULT = sv;
:} 
| selectorvalororeferencia:var
{:
	SecuenciaVariables sv = new SecuenciaVariables();
	sv.addVariable(var);
	RESULT = sv;
:} 

| epsilon ;


//Propaga el identificador de la variable
selectorvalororeferencia ::=  PARAMETROVALOR IDEN:id 
{:
	Var var = new Var (id.getLexema(), null, null);
	RESULT = var;
:}
|expresion:ex
{:
	if(ex.getTipo().equals("IDEN")){
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symTable = scope.getSymbolTable();
		if (symTable.containsSymbol(ex.getValor())){
			semanticErrorManager.semanticFatalError("Variable " +ex.getValor() + " ya declarada");
		} else {
			Var var  = new Var (ex.getId(), null, null);
			RESULT = var;
		}			
	} else {
		semanticErrorManager.semanticFatalError("Error al declarar la variable "+ex.getId()+", identificador no válido");
	}
:};

seccionvariables ::= DECLVARIABLES defvariables:lista
{:
	for (int i = 0; i < lista.size(); i++) {
		//Recuperamos el ámbito donde nos encontramos y obtenemos la tabla de símbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symTable = scope.getSymbolTable();		
		
		//Comprobamos que la variable no este ya contenida en la tabla de símbolos
		if(symTable.containsSymbol(lista.getVariable(i).getId())){
			semanticErrorManager.semanticFatalError("Variable " + lista.getVariable(i).getId() + " ya declarada");
		} else {				
			//Introducimos en la tabla de símbolos la variable con su ámbito, nombre, tipo y valor
			TypeTableIF typeTable = scope.getTypeTable();
			TypeIF type = scopeManager.searchType(lista.getVariable(i).getTipo());	
			
			SymbolVariable simboloVariable = new SymbolVariable(scope, lista.getVariable(i).getId(), type);
			symTable.addSymbol(simboloVariable);			
		}		
	}
:} | epsilon;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

/*--------------------------------------------------------------------------*/
/*------------------------------SUBPROGRAMAS--------------------------------*/
/*--------------------------------------------------------------------------*/
// Reglas de subprogramas
tiporetornofuncion ::= IDEN | tipovector ;

//procedimiento ejemplo (a : entero):
	//variables b,c: entero;
	//comienzo
		//c = a + 2;
		//b = a + c;
	//fin;
procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();
	
	if (typeTable.containsType(id.getLexema()) || symTable.containsSymbol(id.getLexema())) {	
		semanticErrorManager.semanticFatalError("Error al declarar el procedimiento "+id.getLexema()+", identificador en uso");	
    } else {   		
		// Crear Tipo y Simbolo de la Función
		TypeProcedure tipoProcedure = new TypeProcedure(scope, id.getLexema());		
		typeTable.addType(id.getLexema(), tipoProcedure);
		SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope, id.getLexema(), typeTable.getType(id.getLexema()));
        
        symTable.addSymbol(id.getLexema(),simboloProcedimiento);
		
		//Abrir ámbito
		ScopeIF scopeF = scopeManager.openScope (id.getLexema());
    }	
:} 
PIZQUIERDO defvariables:lista
{:
	for (int i = 0; i < lista.size(); i++) {
		//Recuperamos el ámbito donde nos encontramos y obtenemos la tabla de símbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symTable = scope.getSymbolTable();
		
		//Comprobamos que la variable no este ya contenida en la tabla de símbolos
		if(symTable.containsSymbol(lista.getVariable(i).getId())){
			semanticErrorManager.semanticFatalError("Parametro " + lista.getVariable(i).getId() + " con identificador en uso");
		} else {				
			//Introducimos en la tabla de símbolos la variable con su ámbito, nombre, tipo y valor
			TypeTableIF typeTable = scope.getTypeTable();
			TypeIF type = scopeManager.searchType(lista.getVariable(i).getTipo());			
						
			SymbolParameter parametro = new SymbolParameter(scope, lista.getVariable(i).getId(), type);
			symTable.addSymbol(parametro);
						
			TypeProcedure procedimiento = (TypeProcedure)scopeManager.searchType(scope.getName());
			procedimiento.addParametro(parametro);
		}		
	}
:} 
PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias FINBLOQUESENTENCIAS DSENTENCIAS
{:
	scopeManager.closeScope();
:};

funcion ::= DECLAREFUNCION IDEN:id 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();
	
	if (typeTable.containsType(id.getLexema()) || symTable.containsSymbol(id.getLexema())) {	
		semanticErrorManager.semanticFatalError("Error al declarar la funcion "+id.getLexema()+", identificador en uso");	
    } else {   		
		// Crear Tipo y Simbolo de la Función
		TypeFunction tipoFuncion = new TypeFunction(scope, id.getLexema());		
		typeTable.addType(id.getLexema(), tipoFuncion);
		SymbolFunction simboloFuncion = new SymbolFunction(scope, id.getLexema(), typeTable.getType(id.getLexema()));
        
        symTable.addSymbol(id.getLexema(),simboloFuncion);
		
		//Abrir ámbito
		ScopeIF scopeF = scopeManager.openScope (id.getLexema());
    }	
:} 
PIZQUIERDO defvariables:lista
{:
	for (int i = 0; i < lista.size(); i++) {
		//Recuperamos el ámbito donde nos encontramos y obtenemos la tabla de símbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symTable = scope.getSymbolTable();
		
		//Comprobamos que la variable no este ya contenida en la tabla de símbolos
		if(symTable.containsSymbol(lista.getVariable(i).getId())){
			semanticErrorManager.semanticFatalError("Parametro " + lista.getVariable(i).getId() + " con identificador en uso");
		} else {				
			//Introducimos en la tabla de símbolos la variable con su ámbito, nombre, tipo y valor
			TypeTableIF typeTable = scope.getTypeTable();
			TypeIF type = scopeManager.searchType(lista.getVariable(i).getTipo());			
						
			SymbolParameter parametro = new SymbolParameter(scope, lista.getVariable(i).getId(), type);
			symTable.addSymbol(parametro);	
			
			TypeFunction funcion = (TypeFunction)scopeManager.searchType(scope.getName());
			funcion.addParametro(parametro);
		}		
	}
:}  
PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS
{:
	scopeManager.closeScope();
:};

selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;


/*--------------------------------------------------------------------------*/
/*------------------------------EXPRESIONES---------------------------------*/
/*--------------------------------------------------------------------------*/

// Expresiones
expresion ::=  expresion:exp1 MENORQUE expresion:exp2
{: 	
	if (exp1.getTipo().equals("IDEN")){
		exp1.setTipo(scopeManager.searchSymbol(exp1.getId()).getType().getName());
	}
	
	if (exp2.getTipo().equals("IDEN")){
		exp2.setTipo(scopeManager.searchSymbol(exp2.getId()).getType().getName());
	}
	
	if (exp1.getTipo().equals("ENTERO") && exp2.getTipo().equals("ENTERO")){
		Expresion ex = new Expresion("LOGICO", null);
		RESULT = ex;
	} else {
		semanticErrorManager.semanticFatalError("Error en los tipos de la expresion de comparación. Los tipos son diferentes: " + exp1.getTipo() + " y " + exp2.getTipo());
	}
:} 
|  expresion:exp1 IGUALDAD expresion:exp2
{: 
	if (exp1.getTipo().equals("IDEN")){
		exp1.setTipo(scopeManager.searchSymbol(exp1.getId()).getType().getName());
	}
	
	if (exp2.getTipo().equals("IDEN")){
		exp2.setTipo(scopeManager.searchSymbol(exp2.getId()).getType().getName());
	}

	//Si los dos tipos son enteros
	if (exp1.getTipo().equals("ENTERO") && exp2.getTipo().equals("ENTERO")){
		Expresion ex = new Expresion("LOGICO", null);
		RESULT = ex;
	} else {
		semanticErrorManager.semanticFatalError("Error en los tipos de la expresion de comparación. Los tipos son diferentes: " + exp1.getTipo() + " y " + exp2.getTipo());
	}

:} 
| IDEN:id
{: 
	Expresion ex = new Expresion("IDEN", null);
	ex.setId(id.getLexema());	
	RESULT = ex;
:}  
| llamadafuncion 
| CIERTO
{: 
	Expresion ex = new Expresion("LOGICO", "true");
	RESULT = ex;
:}   
| FALSO
{: 
	Expresion ex = new Expresion("LOGICO", "false");
	RESULT = ex;
:}   
| miembrovector 
| NUM:num
{: 
	Expresion ex = new Expresion("ENTERO", num.getLexema());
	RESULT = ex;
:}    
| expresionlvl2:exp
{:
	RESULT = exp;
:} ;
expresionlvl2 ::=  expresion:exp1 SUMA expresion:exp2 
{:
	if (exp1.getTipo().equals("IDEN")){
		exp1.setTipo(scopeManager.searchSymbol(exp1.getId()).getType().getName());
	}
	
	if (exp2.getTipo().equals("IDEN")){
		exp2.setTipo(scopeManager.searchSymbol(exp2.getId()).getType().getName());
	}

	//Si los dos tipos son enteros
	if (exp1.getTipo().equals("ENTERO") && exp2.getTipo().equals("ENTERO")){
		Expresion ex = new Expresion("ENTERO", null);
		RESULT = ex;
	} else {
		semanticErrorManager.semanticFatalError("Error en los tipos de la expresion de comparación. Los tipos son diferentes: " + exp1.getTipo() + " y " + exp2.getTipo());
	}
:}
| expresionlvl3:exp
{:
	RESULT = exp;
:};

expresionlvl3 ::=  expresion:exp1 YLOGICA expresion:exp2
{:
	if (exp1.getTipo().equals("IDEN")){
		exp1.setTipo(scopeManager.searchSymbol(exp1.getId()).getType().getName());
	}
	
	if (exp2.getTipo().equals("IDEN")){
		exp2.setTipo(scopeManager.searchSymbol(exp2.getId()).getType().getName());
	}
	
	if (exp1.getTipo().equals("LOGICO") && exp2.getTipo().equals("LOGICO")){
		Expresion ex = new Expresion("LOGICO", null);
		RESULT = ex;
	} else {
		semanticErrorManager.semanticFatalError("Error en los tipos de la expresion de conjunción lógica. Los tipos son diferentes: " + exp1.getTipo() + " y " + exp2.getTipo());
	}
:} 
|  expresion:exp1 PRODUCTO expresion:exp2 
{:
	if (exp1.getTipo().equals("IDEN")){
		exp1.setTipo(scopeManager.searchSymbol(exp1.getId()).getType().getName());
	}
	
	if (exp2.getTipo().equals("IDEN")){
		exp2.setTipo(scopeManager.searchSymbol(exp2.getId()).getType().getName());
	}

	//Si los dos tipos son enteros
	if (exp1.getTipo().equals("ENTERO") && exp2.getTipo().equals("ENTERO")){
		Expresion ex = new Expresion("ENTERO", null);
		RESULT = ex;
	} else {
		semanticErrorManager.semanticFatalError("Error en los tipos de la expresion de comparación. Los tipos son diferentes: " + exp1.getTipo() + " y " + exp2.getTipo());
	}
:}
| expresionlvl4:exp
{:
	RESULT = exp;
:};

expresionlvl4 ::= NOLOGICO  expresion:exp
{:
	if (exp.getTipo().equals("IDEN")){
		exp.setTipo(scopeManager.searchSymbol(exp.getId()).getType().getName());
	}
	
	if (exp.getTipo().equals("LOGICO")){
		RESULT = exp;
	} else {
		semanticErrorManager.semanticFatalError("Error en la negación. La expresion negada no es de tipo lógico");
	}
:} | expresionlvl5;

expresionlvl5 ::= PIZQUIERDO expresion:exp PDERECHO
{:
	RESULT = exp;
:} 
| CIZQUIERDO expresion:exp CDERECHO
{:
	RESULT = exp;
:};

// Acceso a vectores
miembrovector::= IDEN:id CIZQUIERDO valorango:valor CDERECHO
{: 
	Expresion ex = new Expresion("VECTOR", id.getLexema());
	ex.setRango(valor.getValor());
	RESULT = ex;
:};
 
/*--------------------------------------------------------------------------*/
/*------------------------------ASIGNACION----------------------------------*/
/*--------------------------------------------------------------------------*/ 
 
//i = 3 + 7; 
// Sentencias de asignacion
parteizquierdaasignacion ::= IDEN:id
{:
	Expresion ex = new Expresion (scopeManager.searchSymbol(id.getLexema()).getType().getName(), null);
	ex.setId(id.getLexema());
	RESULT = ex;
:}  
|miembrovector;

sentenciadeasignacion ::= parteizquierdaasignacion:ref ASIGNACION parametroasignacion:exp DSENTENCIAS
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	//Comprobación que la referencia existe en las tablas de símbolos de los ámbitos abiertos 
	//y que es una variable o parámetro de subprograma
	if((scopeManager.containsSymbol(ref.getId()))&&((scopeManager.searchSymbol(ref.getId())instanceof SymbolVariable) || (scopeManager.searchSymbol(ref.getId())instanceof SymbolParameter))){
		if(ref.getTipo().equals(exp.getTipo())){
			System.out.println("Tipos correctos en la asignación");					
		} else {
			semanticErrorManager.semanticFatalError("El tipo de " +ref.getValor()+ " y de " +exp.getValor()+" son incompatibles");
		}
	} else {
		semanticErrorManager.semanticFatalError("La referencia " + ref.getValor()+ " no está declarada");
	}
:}; 

parametroasignacion ::= expresion:ex
{:
	if (ex.getTipo().equals("IDEN")){
		ex.setTipo(scopeManager.searchSymbol(ex.getId()).getType().getName());
		RESULT = ex;
	} else {
		RESULT = ex;
	}
:};

// Llamada a función
parametrofuncionoproc ::= listavariables;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;


// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion ;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon ;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;


// Escribir 
parametroEscribir ::= STRING | expresion | epsilon ;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

// Devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS;



